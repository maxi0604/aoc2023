# AOC 2023
## The plan
With descending priority:
- Solve the challenges
- Have solutions run in reasonable time
- Use a different language for each day
- If the above fails, use a different presentation for the language from before (e. g. local HTML site vs. console output)
- If applicable, get the code running in an environment similar to a real device/deployment environment (e. g. QEMU, after the code is done in ol' reliable [RARS](https://github.com/TheThirdOne/rars))
- Document the process used to get the code running if it's interesting.
- Come up with nice algorithms
- Come up with optimal (with respect to space/time complexity) algorithms

Ideas for languages, in no particular order:
- [x] C
- [x] x86-64 Assembler
- [ ] ARM Assembler
- [ ] Ada
- [ ] C#
- [ ] C++
- [ ] COBOL
- [ ] D
- [ ] Elixir
- [ ] Erlang
- [ ] F#
- [ ] Go
- [ ] Haskell
- [ ] Java
- [ ] Julia
- [ ] Kotlin
- [ ] Lua
- [ ] OCaml
- [ ] One of the Lisps (Probably Common Lisp)
- [ ] PHP
- [ ] Pascal
- [ ] Python
- [ ] R
- [ ] RISC-V Assembler
- [ ] Rust
- [ ] Scala
- [ ] TypeScript
- [ ] VHDL
- [ ] Zig
- [ ] Zsh

Note that there are more languages than days here. This is deliberate.

## Resources
- https://wiki.freepascal.org/Basic_Pascal_Tutorial/Contents
- https://theintobooks.wordpress.com/2019/12/28/hello-world-on-risc-v-with-qemu/
## License
I don't know what you'd be using this for, but if you must: AGPLv3 or later.
## Log
- d1: Finished part 1 with `x86-64 Assembly`, part 2 was becoming too depressing, so I wrote `C` instead. (Wow, wouldn't have expected to ever consider C as an upgrade...)
